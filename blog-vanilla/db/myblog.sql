/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.20-log : Database - myblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`myblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `myblog`;

/*Table structure for table `blogs` */

DROP TABLE IF EXISTS `blogs`;

CREATE TABLE `blogs` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) NOT NULL,
  `content` longtext NOT NULL,
  `createtime` bigint(20) NOT NULL DEFAULT '0',
  `author` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

/*Data for the table `blogs` */

insert  into `blogs`(`id`,`title`,`content`,`createtime`,`author`) values (1,'关于前端学习路线的一些建议（内含经典自测题）','关于前端学习路线的一些建议（内含经典自测题）\r\n前言\r\n这几个月几乎每天都会有朋友加我微信，而他们问的最多的问题就是 —— 前端技术现在如此繁杂，我到底应该如何学习。这个话题太大了，几句话回答不好；也由于这个问题确实困扰了很多前端开发人员，所以我也就着手系统的输出这篇文章。\r\n\r\n虽然这篇文章花了很长时间，肯定也有其局限性；希望各位不吝指出。\r\n\r\n入题\r\n我们俨然能感受到前端岗位现在已经发展成了最重要的研发岗位之一，所以对我们提出的要求也就越来越高。所以我们需要学的也就不仅仅只是 CSS & HTML & JavaScript 了。但这三大件一直都是前端的根本，这一点从未改变。而这三大件中 JavaScript 又是重中之重。\r\n\r\n接下来我会结合我的一点经验，给出前端学习路线的一些具体建议。\r\n\r\n目录\r\n三大件学习\r\n库工具\r\n前端框架（ MVVM ）的学习\r\n浏览器 & 计算机基础\r\n前端工程化\r\n性能优化\r\nNodejs\r\n数据结构和算法\r\n依葫芦画瓢\r\n三大件学习\r\n现在每年依旧有很多初级入门的前端开发。所以对初入门的朋友也给出一点意见。\r\n\r\n刚入门的朋友，我觉得不应该一开始就学习像 Vue、TypeScript、Webpack 等知识。应该把重点放在 CSS & HTML & JavaScript 基础知识的学习上。\r\n\r\nCSS & HTML\r\n对于刚入门的朋友我依旧建议先将 CSS(3) & HTML(5) 的知识点认真学习一边。学习的途中最好是学习完一部分就自己在敲一遍代码，加深自己的记忆。\r\n\r\n当然如果你愿意，建议你可以先仿一个网站的静态页面（掘金、知乎等都可以），有一些属性就可以了解他实际的实现场景。\r\n\r\n当然刚开始敲代码的时候还是不要过分依赖自动补全功能，一开始就使用自动补全对你记忆一些属性时没有帮助的；踏实点学习，日后会有回报的。\r\n\r\n关于 CSS(3) 你需要了解的一些知识点\r\n盒模型（标准 & IE ）\r\nflex、float、Normal Flow 等的理解\r\nCSS 常用选择器\r\n行内、内部、外部样式的区别\r\nCSS 层叠规则\r\nBFC 与 IFC 的了解\r\nCSS3 的 transform、transition、animation 等属性的运用了解\r\n响应式布局的理解\r\n……\r\nCSS 说容易也容易，说复杂也复杂；因为 CSS 总是能给你意外的惊喜。\r\n\r\nHTML(5) 你需要了解的一些知识点\r\n说到 HTML 我想有很多人是 div 一把梭。因为 div 用的爽，不用担心默认样式。\r\n\r\n有人说 HTML 语义化的优点很多，比如清晰的页面结构、有利于 SEO、便于团队开发和维护；这些我都承认，不过我还是喜欢 div 一把梭。\r\n\r\nHTML 语义化( 不是很理解为什么面试总会问 )\r\ncanvas\r\n本地存储（ localStorage、sessionStorage、cookie 的理解 ）\r\nvideo 和 audio 的使用\r\n应用缓存( cache manifest )\r\n……\r\nJavaScript\r\nJavaScript 一直都是我们前端的基石，一定程度上 JavaScript 的理解深度决定了你的发展。所以一定要用心学习。\r\n\r\n现在很多人一看到闭包、原型链、作用域链、继承之类的文章都是直接跳过，你现在可以自问一下你的确理解这些基础的知识点吗？\r\n\r\nJavaScript 的基础知识点确实很多，所以《JavaScript 高级程序设计》 写了 700 多页；不过当你 JS 基础扎实后，你会发现你在学习框架、亦或是学习框架源码的时候会轻松许多。\r\n\r\nJavaScript（ES6+） 你需要了解的一些知识点\r\n类型转换\r\nthis\r\n作用域（作用域链）\r\n原型链以及继承\r\n闭包的理解\r\n动态作用域和词法作用域\r\nJavaScript 执行机制\r\npromise & async\r\n……\r\n上面说的 CSS & HTML & JavaScript 的基础知识点并不需要你一入门就全部都理解透彻；有些虽然是基础，但却也有它的难度。就算是高级也不敢说自己全都掌握了，有句话说的挺好 —— 书读百遍、其义自见。\r\n\r\n我们第一遍学习不可能尽懂，到最少可以给我留下一个印象。过一段时间再学习这块知识点的时候，你肯定会有一个全新的理解。学习只一个需要一直在线的任务，重复的学习可以帮助你保持持续的竞争力。\r\n\r\n我先声明一点，我并没有说其他技术不需要去学习，只不过初入门最好重点是先将基础夯实。\r\n\r\n其实三大件的学习不需要花费多少时间，有基础的大概 3 个月就可以大致的看一遍。 是否真的理解这是后话，不过已经算是入门了。\r\n\r\nCSS & HTML & JavaScript 推荐书籍/网站\r\n_ W3C 的 CSS&HTML 网络教程\r\n《CSS 权威指南》\r\n《CSS 揭秘》\r\n《JavaScript 高级程序设计》\r\n《你不知道的 JavaScript》上卷\r\n_ ECMAScript 6 入门\r\nHTML 不知道推荐什么书。我个人觉得看教程和动手实践就基本没什问题。\r\n\r\n接下来我们就可以学习一些工具类的库了。\r\n\r\n库工具\r\n对于库工具而言我们常用的有 JQuery、underScore、zepto、Moment 等\r\n\r\nJQuery: 降低开发者操作 DOM 的复杂度\r\nUnderScore: 提供实用的函数\r\nZepto: JQuery 的简化版\r\nMoment: 日期和时间操作库\r\n这些库给我们提供了很大的便利，省去了我们编写相关方法的时间，同时也是我们的程序更加稳健 —— 我们自己写的方法很可能在某些情况下就出 bug 了。\r\n\r\n当然对于这些库我们不仅仅只是去了解 API，我们需要去学习它的源码。看看如果自己写相关方法的话是不是也想到了这种方式，这些库工具是也是一个很好地学习工具，我们不应该忽略。\r\n\r\n比如让你自己实现节流函数，你会如何实现。\r\n过滤对象应该如何实现\r\n……\r\n这种问题的答案不就在 Underscore 源码里面吗？\r\n\r\n我们在学习库工具的时候，必定是需要回头看 JavaScript 基础的；这也就进一步夯实了基础。\r\n\r\n前端框架（ MVVM ）的学习\r\n当下最火的框架想必一定是 React 和 Vue，如果 JQuery 的存在是是我们更加方便的操作 DOM,那么现在 MVVM 框架则是让我们从手动更新 DOM 的繁杂操作中解放出来。\r\n\r\n至于 React 和 Vue 该学习哪一个，更多的还是看当下公司使用的是哪一个（也不是必然）。对于 Vue(React) 该如何使用其实不用多久就能上手，我们更应该关心的是他们背后的设计思想和实现原理。\r\n\r\n一些问题\r\n响应式的基本原理是什么\r\n发布订阅模式的理解\r\nVirtual DOM 的理解\r\n前端路由的实现原理\r\nnextTick / setState 的实现原理\r\ndiff 算法\r\n单页面应用（SPA）的原理和优缺点\r\n……\r\n我们对于框架的 API 使用没必要花太多时间，应该多研究他们背后的设计思想和实现原理。\r\n\r\nVue 和 React 我该选择哪一个？\r\n对于这个问题相比很多人都有困扰（有些人两个都学，也就没有这个困扰），这个问题已经有很多人回答了。但我还是觉得不是非要选择哪一个才是政治正确，选择你需要的。\r\n\r\n感兴趣的可以看看这篇文章：\r\nReact or Vue: Which Javascript UI Library Should You Be Using?\r\n\r\n以下是提炼的文中观点：\r\n\r\nVue的优势是：\r\n\r\n模板和渲染函数的弹性选择\r\n简单的语法和项目配置\r\n更快的渲染速度和更小的体积\r\nReact的优势是：\r\n\r\n更适合大型应用和更好的可测试性\r\n同时适用于 Web 端和原生 App\r\n更大的生态系统，更多的支持和好用的工具\r\nVue 相关资料\r\n对于框架的一些学习资料我个人更倾向于推荐官方文档，有很多问题官方文档已经说得很清楚了。市面上有些书籍也就是对官方文档进行了一个扩写（不排除有精良之作）。\r\n\r\nVue 官网 & Vue Router 官网 & Vuex 官网\r\n剖析 Vue.js 内部运行机制 掘金小册\r\nvue 技术揭秘\r\n浏览器 & 计算机基础\r\n如果你希望能能快速进阶到高级工程师，那么对于浏览器 & 计算机基础的知识你就必要又有一定的掌握。因为这能让你更好的理解前端。\r\n\r\n浏览器一直是 JavaScript 最重要的宿主环境，所以我们必须去了解 JavaScript 在浏览器中是如何执行的。\r\n\r\n我们前端开发接触最多的应该就是浏览器了，记得工作第一年最头痛的就是处理 IE 的兼容问题。工作中出现的很多问题都和浏览器有关，所以我觉得了解浏览器工作原理是非常有必要的。\r\n\r\n为何要学习浏览器工作原理？\r\n准确评估 Web 开发项目的可行性\r\n从更高维度审视页面\r\n解决面试中遇到的绝大部分浏览器问题\r\n计算机基础\r\n对于计算机基础我们需要做到大体了解，这样的话我们对整体的流程会有一个大概的把握。在实际开发过程中不会过于被动。\r\n\r\n需要了解的一些知识点\r\n浏览器缓存机制\r\n浏览器中 JavaScript 的执行机制\r\n页面渲染原理\r\n浏览器安全问题\r\n浏览器为什么会跨域\r\n如何系统的优化页面\r\nHTTP 与 HTTPS 的区别\r\nTCP/IP 协议\r\n三次握手和四次挥手\r\nCDN 的作用和原理\r\n正向代理与反向代理的特点\r\n……\r\n这里仅仅列出了一部分知识点，如果想全面的学习可以看下面推荐的资料。\r\n\r\n浏览器 & 网络基础推荐书籍/资料\r\n《浏览器工作原理与实践 》专栏\r\n《图解 HTTP》\r\n《网络是怎样连接的》\r\n前端工程化\r\n从事前端稍微久一点的开发就一定会有这个感受 —— 前端开发越来越工程化，越来越复杂。\r\n\r\n对于前端开发来说，现在前端要做的不只是切页面调接口这么简单，我们需要了解的技术无疑更加广泛。\r\n\r\n前端工程化的一点浅见\r\n由于项目的复杂度越来越高，前端需要做的工作就越来越繁重。当项目复杂就会产生许多问题，比如：\r\n\r\n如何进行高效的多人协作？\r\n如何保证项目的可维护性？\r\n如何提高项目的开发质量？\r\n如何降低项目生产的风险？\r\n前端工程化细分的话我觉得可以分成模块化、组件化、规范化三个方向。或者说一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化的实践。\r\n\r\n模块化\r\nJavaScript 模块化\r\nCSS 模块化\r\n资源模块化\r\n组件化\r\n从 UI 拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。\r\n\r\n也就是将复杂页面按功能拆分成多个独立的组件。\r\n\r\n规范化\r\n编码规范\r\n接口规范\r\ngit 使用规范\r\nCodeReview\r\nUI 元素规范\r\n前端工程化一些知识点\r\n理解 Babel、ESLint、webpack 等工具在项目中的作用\r\nBabel 的核心原理\r\nWebpack 的编译原理、构建流程、热更新原理\r\nnginx 的基本理解\r\n理解 Git 的工作流程\r\nMock 的意义及优点\r\n性能优化\r\n提起性能优化，大家最先想到的是什么？我最先想到的是一道面试题：\r\n\r\n从输入 URL 到页面加载完成的具体过程\r\n\r\n因为从直观层面来看，我们前端需要优化的步骤基本都在这个加载工程当中。\r\n\r\n性能优化现在对于前端来说已经是必不可少的技能了，当然现在有些所谓的性能优化的技巧现在都成为了一种需要遵从的规范。\r\n\r\n我们需要关注两个方向的性能优化：\r\n\r\n运行时的优化\r\n开发时的优化\r\n性能优化一些知识点\r\n前端性能衡量指标、性能监控（performance,LightHouse）\r\n常见的性能优化方案有哪些\r\nSSR 方案的性能优化\r\nWebpack 的性能优化方案\r\nReact、Vue 等框架使用性能优化方案\r\n网络层面的优化方案\r\n页面渲染层面的优化方案\r\n白屏的优化方案\r\n……\r\n推荐资料\r\n《大型网站性能优化实战》\r\n《前端性能优化原理与实践》掘金小册\r\nNodejs\r\n我们知道由于 Nodejs 的出现，前端开发出现了一个新的高潮。JS 开始可以涉及后端领域，JS 的可能性更大了。\r\n\r\nNodejs 一些知识点\r\nNodejs 在应用程序中的作用\r\nExpress 和 Koa 的区别\r\nNodejs 的底层运行原理、和浏览器的异同\r\nNodejs 非阻塞机制的实现原理\r\n……\r\n数据结构和算法\r\n这一点我也比较薄弱，就不展开了。关于这部分你可以刷 leetcode。\r\n\r\n另外推一本书《学习 JavaScript 数据结构与算法》（第三版）\r\n\r\n依葫芦画瓢\r\n我们在项目开发的过程中可以接触到很多优秀的库工具或者是 UI 库。如 lodash、underscore、moment、element-ui、antd design 等。\r\n\r\n我们可能自己设计不出来这么优秀的工具，但是我们完全可以依葫芦画瓢自己按着这些工具写一遍，你就会发现里面有很多不可思议的技巧、优秀的思想。\r\n\r\n依葫芦画瓢对学习来说也是一个非常有用的技巧。\r\n\r\n',1566708695181,'xiaosheng'),(4,'[译] nodejs的未来是什么','Node JS 在non-blocking I/O 看来变得十分出名并且它通过利用 Javascript 在后端和前端中作为一种公用语言使得它的发展变得十分简便。\r\n服务端： 感谢这一门强大的语言以及主要浏览器的支持和协助，Node.js 是在所有程序语言中运行速度最快的一门语言。我最近偶然看到一篇文章，这篇文章谈论到最好的 Node.js 架构，这让我意识到这项技术是如此快的变得流行，这背后有着非常积极和具有热情社群的帮助。Node 包管理器 (NPM) 可能有许多种可能性在其中并且它可能是开始组成一个服务器的最简洁的途径。Node.js 很大程度上不会压制其他的选项然而它将会联合其他不同的选项并继续开发。\r\n前端： 如同你所知的，在前段时间前端疲于联合 HTML 和 including contents . 现在前端包括了应用于你可以组合的未来代码的工具链，而这未来代码是你可以使他一直在更多建立好的程序中以最好的表现运行。Nodejs在前端世界中未来显然是光明的，因为就从目前看起来前端的发展不能没有Nodejs。\r\n不同领域： Node.js 并没有像嵌入，人工智能和ML一样在很多不同的领域内被运用。谷歌在推动这个，在 Data Science front 方面有一些进展，但是还没有看到实际上的发展。\r\nNode  JS的未来：\r\n随着 IT 商业的日益发展，为了给用户带来更好的体验，很多公司都在探索并使用最新的开发技术。Nodejs 也可以被认为是在 IT 商业发展之下的结果之一。\r\n\r\n这一前言创新已经找到了如何推动新业务以及它在庞大组织中专业效果也非常突出。\r\n从根本上来讲，无论在什么时候，出现一个新的技术，IT 界都会在这几月的时间内进行宣传和学习，不过过了这段时间，之后就会被忽略。\r\n但是，上面这种情况并不适用于 Node.js，与相比竞争对手， 它拥有独特的优势，在竞争对手中名列前茅。\r\n在我们继续之前，我们先来介绍一下 Node.js\r\nJS 实际上是建立在 Google 的 V8 JavaScript 引擎上的，这本身就是其流行的主要原因之一。\r\n这是使其成为各种组织的新技术首选的一个因素。\r\n\r\n以下是你为什么要使用Nodejs 的原因：\r\n1 前后端都能使用。\r\nNode.js 能通吃前后端，换个说法，正是因为有了 Node.js 才让  JavaScript 前后端都能使用。并且在服务器端使用，它也和在浏览器中运行类似，这毋庸置疑是令人惊叹的。\r\n2 速度快\r\n如果你喜欢执行快速的应用程序，那么 Node.js 是你不得不尝试下的。组织机构迷恋Nodejs所能提供的速度。以Nodejs 在谷歌 V8 引擎上运行的速度来看，它有着无与伦比的速度。它使用一个独立的串列，使的避免了所有字符串相关的麻烦问题。\r\n3 适用于实时Web应用程序\r\nNode.js 可以以非凡的速度来运行 web 应用程序，同时比较一些用其他语言来家在静态 web 页面或者是博客所需要的时间，会发现 NodeJS 表现非常出色，这难道不是选择 Nodejs 而不是选择其他程序语言的原因吗？\r\n使用 Node.js 的其他优势\r\n有活力的 Node 包管理(NPM)\r\n\r\n易于编码\r\n另类 I/O\r\n解决相关问题的资料丰富\r\n构建具有商业价值的应用\r\n网络驱动\r\n在符合需求的应用上，运行出色\r\n\r\nNode.js 的命运\r\njs 已经变成了网上常常说的 “computerized change structure“.\r\n\r\n它支持用户做任何事情，包括构建微服务、负责多功能应用程序的传输和协调非 Web 框架，以及利用无服务器结构和将物联网（IoT）作为一个阶段。\r\n由于它可以很好地支持这些领域，所以我们可以很好预见到以下两个领域是 Node 开发者可以大展拳脚的地方。\r\n一些人表示，客户可以希望看到其在物联网领域的更多体现方式，就像不同种类的仪器一样。\r\nNode.js提供的实用性和适应性使其成为创建各种 Web 应用程序（包括实时应用程序）的理想解决方案。\r\n考虑到服务端开发和客服端开发一样，使得 Node.js 开发得到广大开发者的认可，很明显它拥有让你快速的上手开发，更好地使用基础设施，以及更突出的数据安全性。\r\n向着始终如一的质量和更佳的稳定性前进，Nodejs 将继续扩大其在云原生领域的地位，就像一个努力奉献的管理者一样。\r\n可以很好地预期，Node.js 将会因为升级和增强排除故障工具而受益。\r\n\r\nNode JS 流行背后的原因\r\n数据库是无缝连接的\r\n\r\n在包含由 MongoDB、Couch 所组成的 NoSQL 数据库流行时，NodeJS 提供了非常简单快捷数据库交互能力，就像 Node js自身环境一样。\r\nNodeJS 运行时状态非常适用于监视和控制无效人工干预的  JSON，而不像其他语言或其他一些阶段需要在中间阶段需要对数据结构执行联合或变更等操作。\r\n\r\n代理服务的能力\r\n\r\nNodeJS 在测试和程序员上面，有着超乎寻常的成功。\r\nNodeJS 可以通过\"中介机构\"的形式，来建立各种各样的\"管理机构\"。\r\nNodeJS 没有全面支持外部通信，如收集信息、准备查询或不将媒体记录保存在 CDN 中。\r\n这样需要仔细的观察到, 如果不需要专业的中介设置，NodeJS 还可以变成一个高效的中介服务器。\r\n\r\n来自社区的贡献支持\r\n\r\n我们已经看到，由于贡献者的数量不断增加，我们可以在网络上看到所有公开发布的资产。\r\nNode 包管理器（npm）使开发人员能够再次使用经过使用和测试的有用代码，并帮助您快速构建强大且十分稳定的应用。\r\n\r\n如果你喜欢的话，构建 web 应用程序非常有趣\r\n从上面可以看出，NodeJs 确实是一项未来主义的技术，已经被许多科技巨头公司采用。如果你是一名刚开始写代码的软件开发工程师，打算从事 PHP 等饱和技术开发刚位，那么转向 NodeJS 无疑会将你的职业生涯提升到一个新的水平。如果你喜欢编写代码和构建应用程序，那么它将非常有趣。虽然与此无关，一个经典的例子是程序员和设计师如何在他们的工作中找乐子的，可以参考 404 error page examples。在这里，创造性在 404 错误页面中展现的淋漓尽致，这篇文章也列出了 web 上出现的一些典型的 404 错误页面。\r\n—2019年3月4日发表\r\n\r\n作者：Rick_Lee\r\n链接：https://juejin.im/post/5d6c7911e51d4561fb04bfaa\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',1566320585135,'ricklee'),(5,'你在 19 年剩余的时间里还能学点什么？','时间过得真快，转眼之间 19 年都已经快进入 9 月份了。\r\n今天就来谈谈在这剩余的时间中我们还可以学点什么来充实自己，提高自己的竞争力。\r\n前端基础\r\n前端基础的重要性我觉得不需要多说了，无论是写出健壮的代码还是定位问题亦或者是面试中都是相当重要的一块内容。\r\n如果你认为自身的前端基础还不过关的话，应该把大量的时间放在学习基础上。\r\n计算机基础\r\n计算机基础对于前端开发者来说最重要的是以下三点：\r\n\r\n网络\r\n数据结构\r\n算法\r\n\r\n以上这三点的共通性在于：你学了它们，在面试的时候总会带来不小的帮助。\r\n这其中网络应该算是最重要的一块内容，毕竟性能优化常常需要你了解一点其中的知识。\r\n另外两者虽然平时工作中很少用到，但是你保不准会遇到需要的时候。另外如果你以后想阅读源码的话，会发现源码中对于数据结构的运用会相当频繁。\r\n框架\r\nAngular 暂且不提，毕竟国内使用率是远不及 React 和 Vue 的。\r\n如果你还没有熟悉框架的使用，在基础打好的前提下可以把精力优先放在这一块，通读文档是关键，因为很多你在开发中可能会遇到的问题在文档中都已经解释了。\r\n如果你已经熟悉它们的使用，那么可以酌情考虑学习一下框架内部的原理。虽说工作上基本不需要你了解框架内部的机制，但是在面试的时间这经常是个必问点。\r\n另外对于使用 Vue 的开发者来说。今年肯定会发布 Vue 3.0，那么新版本的学习应该是必经之路了。\r\n对于使用 React 的开发者来说，切入 Hooks 或许会是一个不错的选择，当然要小心避免其中的坑。\r\n跨端\r\n跨域开发应该是今年热门的一个点，前有 React Native，后有火爆的 Flutter，另外还有各种小程序来横插一杠。\r\n对于 React Native 或者 Flutter 来说。如果不是公司需要你去参与原生的开发，只是单纯的想自己玩一玩的话，那么学习它们我是持保留态度的。\r\n因为学习这门技术并不能提升我的技术能力，充其量只是多具备了一门在原生上写 UI 的能力。如果你想玩转这个领域，那么一定会需要深入原生开发，这个成本就更大了。除非是公司需要，否则花费大量精力在其中个人是认为不值得的。\r\n另外对于小程序来说，微信在这块应该算是龙头老大，当然还有其他的各种小程序。如果你只需要在微信上做小程序开发的话，那么选择余地会相对来说多点。比如 MpVue（千万别选，我踩了一大堆的坑）、Wepy、Taro 等等。\r\n这些框架可以帮助我们快速进入小程序的开发。这些选择中 Taro 相对来说是个不错的选择，社区的活跃度以及反馈都是远远超过其他竞品的，另外也支持编译为多端小程序（其实还能编译成 React Native 和 H5）。唯一的问题应该是限制了你必须使用 React 技术栈。\r\n热门点\r\n列举几个在当下依旧热门的几个技术点：\r\n\r\nTypeScript\r\nGraphQL\r\n\r\nTypeScript 应该算是当下相当热门的一个技术点了。很多框架要不已经 TypeScript 化，要不正在路上。\r\nTypeScript 与 JS 最大的区别就在于增加了静态类型检查（当然一些语法糖也很舒服）。有个这个检查机制，对于开发和维护一个大型项目能带来极大的帮助，无论是修改老代码还是减少 Bug 的发生率。\r\n当然如果你一直在开发小型项目，上不上 TypeScript 其实差别也没那么明显，但是学了并且用了肯定比写 JS 会舒服一点（前提是不要到处 any）。\r\n对于 GraphQL 来说，了解过这块内容的应该都知道它能让请求接口变得相当舒适，当然它也会带来一定的成本，比如说调试困难。\r\n当然虽说 GraphQL 不错，但是学习它最重要的一点我认为是能把它在团队中推动起来。如果推不动，还不如不学。\r\n个人软技能\r\n在这块我认为写 PPT 是个相当重要的软技能。无论评绩效、年终述职、晋升以及技术分享都会需要用到这个技能。\r\n一个优秀的 PPT 是一个相当大的加分项，因为这能让你把想表达的东西更加清晰的呈现给对方。\r\n最后\r\n时间对于大家都是公平的，当下做了学习什么的决定后就不要再过虑了，毕竟没有什么决定在以后是一定正确的，其实决定以后马上行动起来才是正确的。\r\n觉得内容有帮助可以关注下我的公众号 「前端真好玩」咯，定期分享以下主题内容：\r\n\r\n前端小知识、冷知识\r\n原理内容\r\n提升工作效率\r\n个人成长\r\n\r\n作者：yck\r\n链接：https://juejin.im/post/5d627a4cf265da03963ba43c\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',1566320608824,'yck'),(16,'如何从一个菜鸟，变成自己理想中的程序员','前言\r\n从年初的寒冬，到现在的立秋，耗时近6个多月，我终于找到了一份心仪的工作，或者说，我终于找到了工作。工作年薪翻了一倍还要多不少(个人起点太低了~)。\r\n也有将近一个多月没有写博客了，这里就把自己这段时间的感悟以及如何去学习的，与大家分享一下，可能掺杂了很多个人感想，所以废话可能会有些多，望大家见谅！！！\r\n下面分几个阶段来描述一下笔者的心理历程经历\r\n第一阶段 自我认识、危机感来袭\r\n笔者16年毕业，毕业后便入坑，第一家公司iOS开发也就我一人，完全靠自学（个人感觉啥都没学到，整天上班就是网上找资料状态），终于成功的在16年11月份倒闭了，然后我就失业了。\r\n历时几个月笔者都没有找到工作，然后自己就买了本《Object-C高级编程》来学习，当时看这本书，其实是相当于天书一样，看不懂，但还是强迫自己看了。\r\n终于在17年的2月份找到了一家公司，也是一家小公司。事后才知道自己被面上的原因是因为面试的时候，还在看上面说的那本书，然后面试官感觉笔者学习的态度可以，所以就打算让我尝试一下，有些尴尬。 不过也没有让公司失望，安全的度过了实习期，并且一直就职到现在，公司也快速的发展了起来，很为公司感觉到开心。\r\n在18年年中，笔者开始接触了Flutter，那个时候的Flutter并没有现在这样火，自学了一段时间，感觉自己的理解还是仅仅存在简单的使用层面，并没有大佬们说的那种语言都是相通的感觉。仿佛意识到了，我连自己赖以生存的语言都没有学会，就想着扩展自己的知识层面，于是自嘲了自己一段时间。\r\n上面事件之后，也是笔者学习的开始吧，后来，我停下了任何娱乐，比如小说、游戏和锻炼，开始自我认识，实际上指的是iOS开发自己所拥有的技能的梳理，大致是这样的：\r\n\r\n简单UI界面没问题\r\n对于什么设计模式，完全不懂，甚至单例我都没有搞清楚怎么用的\r\n底层，我靠，底层怎么实现的我怎么知道？\r\n数据结构、算法？我做移动端的要知道这些东西干嘛？\r\n\r\n好吧，笔者不想描述的更清晰了，相信就单纯的上面几条，相信大家应该都知道，菜到什么程度。\r\n此时，甚至一段时间，笔者都非常的迷茫，感觉到了深深的危机，我该怎么办，我能做什么？那段时间，一直在问自己这些问题。\r\n第二阶段 学习\r\n经过一段时间调整后，放弃了Flutter，拿起了大学的数据结构的课本，开始认识啥是链表、哈希表等一些简单的数据结构，此时的学习也就是简单的知道这玩意到底是啥，因为iOS的封装，日常开发根本用不到这些东西，但是大家都说这个基础，所以笔者就开始学这些。\r\n与此同时，笔者也购买了《Effective Objective-C 2.0》学习，这些书籍也是大佬们在网上极力推荐的，所以我就买。\r\n当认识了简单的数据结构以及读完上面那本书之后，就有点自我感觉良好的感觉，然后就在我老婆面前show一下我的成果（我老婆也是程序员，后台，比我优秀），然后她就问了我一些关于简单数据结构的实现方法，以及一些简单的底层问题。 啊~，被虐的体无完肤，甚至感觉到了羞愧。因为不懂，无法组织语言描述出来，她还问我，能否用OC去实现一个简单的链表和hash表，啪啪啪，脸很疼。\r\n男人可以认怂，但是在自己女人面前认怂，是绝对不可能的。在这种羞愧感之下，我认真的去了解链表、hash表以及简单的二叉树。同时用OC语言去实现它，其实关于hash表的实现，笔者也以博客的形式分享给大家了笔记-数据结构之 Hash（OC的粗略实现）。\r\n了解相关的数据结构之后，我就带着我的理解，去看我上面所提到的两本书，关于数据结构，在iOS中的利用，也已博客的形式分享给大家了笔记-集合NSSet、字典NSDictionary的底层实现原理。 当然这些都是浅显的了解，不过正是因为这些简单的了解，激发了我对底层方面研究的兴趣。\r\n这个阶段的学习，持续了近半年的时间，工作中要求做视频相关的播放，然后我一人“独挽狂澜”的接下了这个模块的任务（实际上也就是利用第三方库ZFPlayer去做视频的播放），然后自己利用空余时间去研究数据结构，感觉学到了很多。于是又出现了自我膨胀的感觉，所以就牛逼哄哄的出去找工作，刚好处于18年年底，行情还是可以的。\r\n第三阶段 谷底，彻底的谷底\r\n18年年底的时候，出去面了一家公司，属于小公司，需要做视频相关的App。先给我来了一个简单的电话面试，问了工作中做了些什么，以及遇到了什么样的困难，然后怎么解决掉的，正常回答之后，电话面试过了。\r\n然后去他们公司面试，去了之后发现是一个项目负责人面我，而且这个是新项目，之前的那个电话面试我的人是兼职的，现在没时间兼职了，所以需要找一个iOS开发，要求就是有视频相关的经验，然后我就把我的经验分享了一下，当然存在了一些吹逼。然后就拿到了一个17k的offer。\r\n恩，确实，拿到这个之后，完全膨胀到了极点，因为这个薪资比我当时的工资高的太多。但是因为某些原因，我拒绝了，因为当时某些原因，不能换工作，而且我感觉我能拿到更好的offer。\r\n度过春节，来到金三银四，我投了很多家大厂，比如B站、携程、听喜马拉雅等等。当时简历写的也确实漂亮，都成功的拿到了面试邀请，当时开心的很。\r\n恩，后面在面试的过程中，没有一家的面试时间超过半小时，也没有一家给我二面的。怀疑人生，彻底的懵逼了。\r\n其实一面都非常的简单，简单的罗列几点：\r\n\r\nblock本质\r\nARC内存管理的原则\r\n多线程之间的通讯\r\nruntime、runLoop的理解和使用\r\n常见三方库的源码等等\r\n\r\n说实在的，一面的这些东西，真的非常基础，然而笔者当时仅仅停留在听过，网上看过相关的博客，当真正需要我用自己的语言去描述的话，那就是漏洞百出。\r\n后面不用说太多，笔者深深的陷入了怀疑自我的状态，想过转行，想过就呆在现在的公司挺好，后期甚至对面试产生了一种抗拒，害怕面试。\r\n第四阶段 再次学习\r\n在一段时间的缓冲之后，我选择了再次学习，学习初期，比较盲目，只是通过网上资料、书籍来自学，收获很低。\r\n下面的描述，绝对不是广告，确实是个人的学习之路。\r\n在一次偶然的机会，观看了逻辑教育的公开课的视频，先是看了Cooci老师的公开课，后面又看了CC老师关于图片渲染的公开课，后面几天就一直跟着这个学，但是公开课，能学到的东西确实少，就下定决心报了一个VIP的课程。\r\n贵，当时确实感觉好贵，一个课程都要7K+，当时犹豫了几天，后面在自我安慰的状态下，报名了进行了系统的学习。直播课时间是每周的一、三、五晚上8点开始。\r\n说上课时间，为了更好的表达我自己的学习时间安排。\r\n\r\n周一、三、五晚上上直播课，每晚基本上10点后结束，上完课，我就复习总结，自己写笔记，能忙到凌晨1~2点钟\r\n每天的上下班的路上，就看直播课的视频，反复学习\r\n周二、四、六晚上没有课，那我就总结笔记，写博客，有疑问的直接问上课老师或者和同学交流，真的是一点不愿意耽误时间。\r\n周末时间，公司是大小周，小周的话，我就全天学习，去消化一周所学的知识，大周的话，我会留出半天时间陪老婆，实在忙不过来的时候，我会两天都处在学习阶段。\r\n\r\n其实这么的努力学习不为别的，就为了那昂贵的学费，就为了能够多学点知识。\r\n就这样的持续学习，一直到现在，其实直播课，课堂上能学到的东西有限，毕竟大家的接受能力不一样，笔者就是属于理解能力比较差的，需要用更多的时间去总结，然后使用。\r\n再艰难的过程，简单的文字能够轻描淡写的描述过去，其中的经历体验只有自己知道。当自己沉下去，去学习的时候，需要的就是坚持，坚持，再坚持。当你感觉时间不够用，或者感觉放松都是在浪费时间的时候，我感觉，你离成功不远了。\r\n第五阶段 再次出发\r\n就在2周前，我再次出发，投简历，反应很快，两天时间，安排了5家公司的面试。可是心里仍然对面试有心里阴影，就把最想去的公司安排了最后。\r\n这次面试前，没有看任何相关的面试题，因为自己一直处于学习的过程，感觉面试题对我的帮助不是很大，或者也算是一种自信吧。\r\n黑暗之后，黎明终会到来，结果也让笔者自己满意，面试了5家，也成功的拿到了5个offer，最终选择了自己最心仪的一家公司。拿到了20k+，16薪的工作。\r\n面试中，也有一次面了5轮的，也有视频面试的，总之面试很累，还有一家8年的老开发一起交流技术，他们给了笔者很多宝贵的建议，以及学习的方向，很是感谢他们。\r\n学习的方式很多，对于笔者这种自学能力不能太好的，或者说没有学习方法的人来说，付费学习，也是一种捷径。\r\n这个过程，笔者抛去了以往容易自我膨胀的心态，让自己时刻处于一种不满足的紧张感，时时刻刻处于学习的状态。\r\n以上就是笔者近一年的历程，感觉自己成功的度过了菜鸟的阶段，现在已工作了3年，争取在第5年的时候，上升一个更高的层次，希望大家也在这里对我进行监督。\r\n也希望这篇文章能给学途比较迷茫的小伙伴带来一点点坚持下去的动力，要相信，熬过了最难的时间，美好便会降临。\r\n后面又是一个新的开始，仍然需要沉下心来，去学习，去沉淀。\r\n\r\n作者：佐笾\r\n链接：https://juejin.im/post/5d5e68f5e51d4561af16dd2b\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',1566708939451,'zuo'),(17,'谈谈V8引擎GC原理','前言\r\n过去这些年 V8 的垃圾回收器（GC）发生了很多的变化，Orinoco 项目采用了 stop-the-world 垃圾回收器，以使其变成了一个更加并行，并发和增量的垃圾回收器。\r\n调用栈中数据是如何回收的？\r\n我们先来说说调用栈中数据是如何回收的垃圾的。首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：\r\nfunction foo(){\r\n    var a = 1\r\n    var b = {name:\" 极客邦 \"}\r\n    function showName(){\r\n      var c = \" 极客时间 \"\r\n      var d = {name:\" 极客时间 \"}\r\n    }\r\n    showName()\r\n}\r\nfoo()\r\n复制代码当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：\r\n从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。我们可以想想，当执行完foo函数之后，在堆中的内存是如何回收的呢？\r\n接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP(录当前执行状态的指针) 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。具体如下图\r\n\r\n作者：bug_killer\r\n所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。\r\n堆中的数据是如何回收的？\r\n从上面我们知道，当执行完foo函数之后，ESP 应该是指向全局执行上下文的，但是保存在堆中的两个对象依然占用着空间，如下图所示：\r\n\r\n要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。\r\n代际假说&&V8回收垃圾机制\r\n代际假说\r\n在垃圾回收中有一个重要的术语：“代际假说”；代际假说表明很多对象在内存中存在的时间很短。换句话说，从垃圾回收的角度来看，很多对象一经分配内存空间随即就变成了不可访问的。这个假说不仅仅适用于 V8 和 JavaScript，\r\n代际假说有以下两个特点：\r\n1.第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；\r\n2.第二个是不死的对象，会活得更久。\r\n分代堆布局\r\n堆在 V8 中会分为两块不同的区域，这两块区域分别称之为老生代和新生代，新生代又进一步分为 ‘nursery’（from-space） 子代和 ‘intermediate’ (to-space)子代两块区域； 一个对象第一次分配内存时会被分配到新生代中的‘from-space’ 子代；如果进过下一次垃圾回收这个对象还存在新生代中，这时候我们移动到 ‘to-space’ 子代，再经过下一次垃圾回收这个对象还在新生代，这时候我们就会把这个对象移动到老生代。\r\n\r\n\r\nV8中堆分成两代，如果经过垃圾回收对象还存活的话会从新生代移动到老生代\r\nV8两种垃圾回收器\r\nV8 有两个垃圾回收器，一个是主垃圾回收器，一个是副垃圾回收器。主垃圾回收器从整个堆中回收垃圾，副垃圾回收器（Scavenger）从新生代中回收垃圾。主垃圾回收器可以很有效的从整个堆中回收垃圾，但是代际假说告诉我们新分配内存的对象也极有可能需要垃圾回收。\r\n副垃圾回收器 —— (Scavenger)\r\n副垃圾回收器只从新生代中回收垃圾，幸存的对象总是会被分配到内存页中去。在清理时，初始的空闲区域称之为“To-Space”，复制对象过来的区域称之为“From-Space”；在最坏的情况下，如果每一个对象在清理的时候存活了下来，那我们就要复制每一个对象。\r\n对于清理，我们会维护一个额外的根集，这个根集里会存放一些从旧到新的引用。这些引用是在旧空间（old-space）中指向新生代中对象的指针。我们使用这个指针来维护从旧到新的引用列表，而不是跟踪整个堆中的每一个对象变更。当堆和全局对象结合使用时，我们知道每一个在新生代中对象的引用，而无需追踪整个老生代。\r\n然后将所有的活动对象移动到连续的一块内存中，这样做的好处就是完全移除内存碎片（清理非活动对象时留下的内存碎片）；然后我们把两块内存空间互换，即把 ‘To-Space’ 变成 ‘From-Space’，反之亦然。一旦垃圾回收完成，新分配的内存空间将从 ‘From-Space’ 下一个空闲内存地址开始。\r\n\r\n副垃圾回收器移动活动对象到一个新的内存页\r\n如果仅仅是凭借这一策略，我们就会很快的耗尽新生代的内存空间；为了新生代的内存空间不被耗尽，在下一次垃圾回收的时候，我们会把活动对象移动到老生代，而不是 ‘To-Space’。\r\n清理的最后一步是把移动后的对象的指针地址更新，每一个被复制对象都会留下一个转发地址，用于更新指针以指向新的地址。\r\n\r\n副垃圾回收器移动 ‘to-space’ 子代的活动对象到老生代\r\n主垃圾回收器\r\n主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。\r\n由于老生区的对象比较大，若要在老生区中使用 Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，\r\n同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。\r\n首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\r\n\r\n接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：\r\n\r\n上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact）这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图\r\n\r\nOrinoco回收执行机制\r\nOrinoco 是 V8 垃圾回收器项目的代号，它利用最新的和最好的垃圾回收技术来降低主线程挂起的时间， 比如：并行（parallel）垃圾回收，增量（incremental）垃圾回收和并发（concurrent）垃圾回收。\r\n并行垃圾回收\r\n并行是主线程和协助线程同时执行同样的工作，但是这仍然是一种 ‘stop-the-world’ 的垃圾回收方式，但是垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。这是这三种技术中最简单的 JavaScript 垃圾回收方式；因为没有 JavaScript 的执行，因此只要确保同时只有一个协助线程在访问对象就好了。\r\n\r\n增量垃圾回收\r\n增量式垃圾回收是主线程间歇性的去做少量的垃圾回收的方式。我们不会在增量式垃圾回收的时候执行整个垃圾回收的过程，只是整个垃圾回收过程中的一小部分工作。做这样的工作是极其困难的，因为 JavaScript 也在做增量式垃圾回收的时候同时执行，这意味着堆的状态已经发生了变化，这有可能会导致之前的增量回收工作完全无效。从图中可以看出并没有减少主线程暂停的时间（事实上，通常会略微增加），只会随着时间的推移而增长。但这仍然是解决问题的的好方法，通过 JavaScript 间歇性的执行，同时也间歇性的去做垃圾回收工作，JavaScript 的执行仍然可以在用户输入或者执行动画的时候得到及时的响应。\r\n\r\n并发垃圾回收\r\n并发是主线程一直执行 JavaScript，而辅助线程在后台完全的执行垃圾回收。这种方式是这三种技术中最难的一种，JavaScript 堆里面的内容随时都有可能发生变化，从而使之前做的工作完全无效。最重要的是，现在有读/写竞争（read/write races），主线程和辅助线程极有可能在同一时间去更改同一个对象。这种方式的优势也非常明显，主线程不会被挂起，JavaScript 可以自由地执行 ，尽管为了保证同一对象同一时间只有一个辅助线程在修改而带来的一些同步开销。\r\n\r\n总结\r\n大部分 JavaScript 开发人员并不需要考虑垃圾回收，但是了解一些垃圾回收的内部原理，可以帮助你了解内存的使用情况，以及采取合适的编范式。\r\n从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理Orinoco回收执行机制的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。',1566708955863,'bug_killer'),(18,'Vue从甜小白到皮大佬系列(七) Vue Router','啥是Vue Router?\r\n官方传送门\r\nVue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌,在我们项目中也是必会技能之一。下面我想通过以下几个方面来分享。\r\n一、集成Vue Router\r\n\r\n\r\n1.如果安装了vue脚手架cli3 在create项目的时候会有安装Vue router的选项,选中敲空格就会默认安装Vue router\r\n\r\n\r\n2.如果在create项目的时候没有自动安装,那么要手动进行安装.\r\n\r\n\r\nnpm i vue-router --save\r\n复制代码\r\n3.安装好vue-router后最好在src文件下创建一个router.js来专门管理整个项目的路由结构\r\n\r\n二、使用Vue Router\r\n1.简单构建一个通过浏览器输入访问地址的路由\r\n\r\n1.src目录下创建一个router.js文件然后在文件中构建路由数组并导出,一定要注意构建路由数组是routes而不是routers哦!!\r\n\r\nimport Vue from \'vue\'\r\nimport Router from \'vue-router\'\r\nVue.use(Router)\r\nexport default new Router({\r\n    // 构建路由数组\r\n    routes: [{\r\n       \r\n    }]\r\n})\r\n复制代码\r\n2.在main.js文件中全局引用router.js并挂载到项目中\r\n\r\n// 引入router.js\r\nimport router from \'vue-router\'\r\nVue.config.productionTip = false\r\nnew Vue({\r\n    router,\r\n    render: h => h(App),\r\n}).$mount(\'#app\')\r\n复制代码目标:通过路由localhost:8080/#/home跳转到Home组件界面\r\n\r\n3.构建一个Home.vue的组件,\r\n在router.js中构建routes的配置\r\n\r\nimport Vue from \'vue\'\r\nimport Router from \'vue-router\'\r\n\r\n// 引入views\r\nimport Home from \'./views/Home.vue\'\r\nVue.use(Router);\r\nexport default new Router({\r\n    routes: [{\r\n        path: \'/home\',\r\n        name: \'home\',\r\n        component: Home\r\n    }]\r\n})\r\n复制代码\r\n4.给Home组件配置出口<router-view></router-view>,这一步非常关键!!没有出口,是不会显示出来的.\r\n\r\n\r\n在App.vue中\r\n<template>\r\n  <div id=\"app\">\r\n    <router-view></router-view>\r\n  </div>\r\n</template>\r\n复制代码至此一个简单的路由配置就完美的配置完了,浏览器输入localhost:8080/#/home就可以访问啦!如果有多个组件需要配置路由,都可以在router.js中配置.\r\n引入图片\r\n2.router-link\r\n说明:router-link其实就是封装的a标签\r\n<router-link to=\"/home\">Home</router-link>\r\n复制代码3.vue-router配置子路由\r\n说明:访问二级或三级页面的时候需要配置子路由.\r\nApp.vue\r\n<template>\r\n  <div id=\"app\">\r\n    <p>导航 ：\r\n      <router-link to=\"/\">首页</router-link> |\r\n      <router-link to=\"/home\">Home页面</router-link> |\r\n      <router-link to=\"/home/about\">-About界面</router-link> |\r\n      <router-link to=\"/home/me\">-Me页面</router-link>\r\n    </p>\r\n    <router-view></router-view>\r\n  </div>\r\n</template>\r\n复制代码router.js中配置home的children路由\r\n{path: \'/home\',\r\ncomponent: Home,\r\nchildren: [\r\n           {path: \'about\',component: About},\r\n           {path: \'me\',component: Me}]\r\n}\r\n复制代码注意点:在Home.vue中一定要添加出口<router-view></router-view>否则不会生效\r\nvue-router如何参数传递\r\n1.用$route的params来动态传参\r\n\r\n通过$route.name的形式来接受参数name这个参数\r\n定义路由path键值对的形式传参\r\n\r\n  routes: [{\r\n        path: \'/home/:name/:age/:height\',\r\n        name: \'home\',\r\n        component: Home\r\n    }]\r\n复制代码在浏览器中输入localhost:8080/#/home/name=james/age=26/height=180\r\n\r\n在App.vue中通过this.$route.params来动态取值\r\n\r\n2.$route的query来动态传参\r\n$route.params仅能取到类似localhost:8080/#/home/name=james/age=26/height=180的地址传过来的参数,如果是localhost:8080/#/home/name=james/age=26/height=180?sex=男 带 ?,只能通过$route.query的方式来取值\r\n性别{{this.$route.query.sex}}\r\n复制代码上面两种方式是为了区分路由动态传递的参数的性质来分区取值,我们还可以直接封装方法,取值的时候不用这么麻烦,可以通过props传值\r\n在router.js中\r\nlet fun = ({parms,query}=>{\r\nreturn {\r\n    age:param.age,\r\n    sex:param.sex,\r\n    height:query.height,\r\n}\r\n})\r\n// 通过props传值\r\n{path:\'/home/:sex?height\',name:\'mine\',component:Mine,props:fun}\r\n复制代码// 定义接受的参数\r\nprops:[\'name\',\'sex\',\'height\']\r\n复制代码//直接取值\r\n{{name}}\r\n{{sex}}\r\n{{height}}\r\n复制代码三、导航守卫\r\n1.什么是路由守卫?\r\n通过路由守卫可以刷新或进入的路由界面进行权限验证,相当于Vue全局的中间件\r\n2.全局守卫\r\n任何一个路由进入都可以先拦截,然后根据添加跳转不同的路由。\r\n关键Code:\r\nrouter.js中\r\nconst router = new VueRouter({.....})\r\nrouter.beforeEach((to,from,next)=>{\r\n    if (to.path !== \'login\') { //验证是否登录\r\n        if(window.isLogin) {\r\n            next();\r\n        } else {  //没有登录\r\n            next(\'/login?redirect=\'+to.path);\r\n        }\r\n    } else { //不需要验证\r\n        next();\r\n    }\r\n    next();\r\n})\r\n复制代码3.局部守卫\r\n只控制某单个组件的路由在routes数组里做控制,和全局一样需要beforeEach\r\n4.生命周期\r\n\r\nbeforeRouteEnter\r\n进入之前调用\r\nbeforeRouteUpdate\r\n路由参数变了\r\nbeforeRouterLeave\r\n路由离开之前\r\n\r\n四、路由懒加载\r\n用的时候在加载,提高性能\r\n1.懒加载的使用方法:\r\n改变组件的引入方式:\r\n由之前的\r\nimport About from \'./views/About\'\r\n复制代码转变为\r\nconst About = ()=> import(\'./views/About\')\r\n复制代码这样就轻松的实现了路由的懒加载啦!\r\n相关API\r\n\r\n\r\nthis.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)\r\n\r\n\r\nthis.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)\r\n\r\n\r\nthis.$router.back(): 请求(返回)上一个记录路由\r\n\r\n\r\nthis.$router.go(-1): 请求(返回)上一个记录路由\r\n\r\n\r\nthis.$router.go(1): 请求下一个记录路由\r\n\r\n\r\n$router 和 $route的区别\r\n\r\n$router\r\n\r\n\r\nrouter是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象,这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性\r\n\r\n\r\n$route\r\n\r\n\r\nroute是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象可以获取对应的name,path,params,query等\r\n\r\n作者：极客James\r\n链接：https://juejin.im/post/5d6e6f366fb9a06b32609021\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',1567577815388,'James'),(19,'前端内存泄露浅析','手上负责的vue项目最近出现一个这样的问题，用户用着用着就出现：”喔唷，崩溃啦！“的提示。\r\n做了以下性能优化尝试：\r\n\r\n主动销毁对象及其子对象\r\n主动取消监听listener\r\n本地搜索减少组件DOM渲染\r\n\r\n主动销毁对象及其子对象\r\nvue-cropper.js，组件实例不会主动销毁，需要主动调用destroy方法销毁。\r\ncreatejs/easeljs，组件实例需要手动销毁canvas画布，maker.stage.canvas = null;maker.stage.removeAllChildren();\r\n主动取消监听listener\r\ncreatejs/easeljs，maker.stage._eventListeners = null;maker.stage.removeAllEventListeners();。\r\n本地搜索减少组件DOM渲染\r\niview的select组件，当数据量过大时，DOM渲染会占用很大的内存，非常吃性能。因此为其增加了渲染指定个数的功能，例如首次渲染只渲染20个，之后的搜索从已经加载好的数据中搜索并渲染。\r\n有一定的收效，但是在仍然存在性能问题，切换菜单的过程中，Memory中的Javascript VM instance以100MB/次的速度增加，而且还是在没有数据的情况下。\r\n因此，迫切的需要一次深度的性能优化，以解决当前项目遇到的问题。\r\n解决完这个问题我将增强技能：\r\n\r\nChrome DevTools的Memory，Performance工具的应用\r\nvue相关，javascript相关，DOM相关的未知内存泄漏知识点\r\n\r\n我将记录以下深度分析内存泄露的相关内容：\r\n\r\n内存泄露分析Snapshot相关知识点\r\n内存泄露分析Snapshot的疑惑和实践\r\nChrome DevTools Elements的Event Listeners分析内存泄露\r\n\r\n内存泄露分析Snapshot相关知识点\r\nJS heap size\r\nwindow.performance.memory对象的属性。\r\njsHeapSizeLimit: 2197815296\r\ntotalJSHeapSize: 12068848\r\nusedJSHeapSize: 10730032\r\n复制代码totalJSHeapSize和usedJSHeapSize的区别是什么？\r\nusedJsHeapSize是内存总数：指的是JS对象占用的内存，包括V8内部对象。\r\ntotalJsHeapSize是当前内存总数：指的是JS堆的占用的内存，包括任意js对象的空闲内存。\r\n通过以下代码，可以观察当前document的usedJSHeapSize占用状况，从而分析是否存在内存泄露性能问题。\r\nsetInterval(()=>{\r\n	console.log(performance.memory);\r\n},2000)\r\n\r\n通过观察可以发现，js占用内存（不包括空闲内存）在一直升高，停留一段时间以后也GC不到页面初始化的的大小。\r\n因此可以得出结论，存在内存泄露。\r\n也可以在Chrome的任务管理器中，开启JavaScript使用的内存的监控。但是这样会开启看到所有tab甚至是插件的内存占用信息，不如code的方式直观和geek。\r\nHeap snapshot\r\n堆快照。其实就是当前页面的js对象及其相关的DOM节点的内存分布情况。\r\n\r\n内存未泄露堆快照\r\n内存泄露堆快照\r\n\r\n可以在内存泄露前生成一份堆快照，再在内存泄露后生成一份堆快照。通过对比的方式，找出两份堆快照存在的内存泄露点。最好是在一次操作后分析，以便分析出问题。\r\nShallow Size\r\nShallow Size 是对象本身hold的内存。\r\njs会为对象自身开辟一些空间用来存储数据。js中string和array会有明显的shallow size， 不过它们主要在渲染内存中存储，在js heap上仅仅暴露一个包裹对象。\r\n渲染内存指的是监测页面的所有内存：\r\n\r\n原生内存（native memory）\r\n页面的js堆内存（js Heap memory）\r\n页面开启的所有worker的js堆内存（JS heap memory of all dedicated workers）\r\n\r\n参考资料：即使是一个小对象，都可能间接的hold了庞大的内存。从而导致自动GC程序不能处理掉这些被间接hold的内存。\r\nRetained Size\r\n这是删除了对象及其依赖对象后，可以释放的内存大小，这些依赖从GC root是无法访问到的。\r\n官方解释很拗口，简单理解其实就是对象及其依赖对象的内存大小。\r\nComparison中的分析字段\r\n\r\n# New\r\n新创建的对象个数。\r\n# Deleted\r\n删除的对象个数。\r\n# Delta\r\n发生变化的全部对象的个数。净增对象个数。\r\nAlloc.Size\r\n已经分配的使用中的内存空间。\r\nFreed Size\r\n新对象释放出的内存空间。\r\nSize Delta\r\n发生变化的释放内存的全部空间。净增内存空间。\r\n\r\nHeap Snapshot中的Constructor\r\n\r\n(closure) 通过函数闭包对一组对象的引用计数\r\n(array、string、number、regexp) 不同对象类型的列表，Array，String，Number，RexExp的属性\r\n(已编译代码) 与已编译代码相关的任何内容。\r\nHTMLDivElement、HTMLAnchorElement、DocumentFragment DOM对象。\r\nDep、Observer、VNode、Watcher、VueComponent 这些是vue特有的对象。\r\n\r\n一个构造函数的属性\r\n\r\ncode :: (CompileLazy builtin) V8的builtins\r\ncontext :: system/NativeContext V8的heap/factory.cc\r\nfeedback_cell::system V8的heap/factory.cc\r\nmap::system/Map V8的heap/factory.cc\r\nshared [V8的heap/factory.cc]指的是SharedFunctionInfos 这是一个介于函数和已编译代码的对象，SFI没有上下文。\r\n\r\nfunction_data 函数数据\r\nname_or_scope_info 函数名称和作用域信息\r\nscript_or_debug_info 脚本或者debug信息\r\n\r\n\r\n\r\nShallow size、Retained size、Freed size、Delta size的size是以什么为单位？\r\n所有的size都是以字节为单位的。\r\n\r\nNote: Both the Shallow and Retained size columns represent data in bytes.\r\n\r\n内存泄露分析Snapshot的疑惑和实践\r\n为什么一次菜单切换会导致6MB的内存泄露？\r\n\r\n素材列表->产品列表->素材列表，增加了6MB的内存占用。\r\n经过对比发现，主要增大的是Object的Retained Size，从26913个（37%）增大到32933个（49%），增大了12%。\r\n刚好VueComponent也从377个（10%）增大到600个（22%），也是从增大了12%。\r\n所以初步断定，是由于VueComponent没有GC导致的。\r\n第一组疑问（理论）:\r\n\r\n是有对象没有被销毁吗？\r\n是对象销毁了但是由于其他对象依赖它，导致销毁失败吗？\r\n是对象销毁了但是由于其他对象依赖它的子对象，导致销毁失败吗？\r\n\r\n以上信息是在Summary中展示的，那么如何对比两次快照呢？\r\nChrome DevTools提供了一个非常便利的功能，Comparison，切换到想要对比的Snapshot，即可得到2次内存占用的diff。\r\n经过第二次和第一次的对比，我们得到这张对比分析图。\r\n\r\n第二组疑问（实践）： 组件作为实例的组件，不会跟随父组件自动销毁吗？ 是不是通用组件的问题？一个通用组件在多处引用，导致页面销毁后，当前实例的组件没有彻底销毁？\r\n\r\n#Delta值最高的(closure)是主要的原因吗？\r\n在(closure)的末尾，我们找到很熟悉的通用组件面孔，以此为出发点去做分析。\r\nshared是很可疑的，点开以后是下图的场景。\r\n组件在这里出现，说明这个模块/组件闭包内部变量使用完后没有置为null。\r\nvue并不会监测到组件/模块不再使用，所以我们需要在vue的destroyed或者beforeDestroy生命周期中做主动销毁。\r\n<script>\r\nimport ALIOSS from \'@/components/uploadToOss\';\r\nlet commonOSS = new ALIOSS();\r\n\r\nexport default {\r\n    beforeDestroy() {\r\n        commonOSS = null; // 这是新增的代码，销毁创建的上传OSS组件实例，释放闭包空间\r\n    }\r\n}\r\n</script>\r\n复制代码一定要注意，vue是监测不到我们不用某些模块的，只有绑定在vue实例上的实例才会与组件一起销毁，没有绑定的一定要主动销毁。\r\n置为null前\r\n\r\n我们成功释放了112byte，也就是0.112Kb的内存！\r\n\r\n是有对象没有被销毁吗？是的，引入的模块没有被销毁。\r\n是对象销毁了但是由于其他对象依赖它，导致销毁失败吗？不是，我们暴露的一般是一个class，新建的实例有自己的上下文，不存在单文件组件间互相引用，因此是独立的。\r\n是对象销毁了但是由于其他对象依赖它的子对象，导致销毁失败吗？对象销毁后其子对象也会自动销毁。\r\n组件作为实例的组件，不会跟随父组件自动销毁吗？会销毁的。每次引入都是独立的。\r\n是不是通用组件的问题？一个通用组件在多处引用，导致页面销毁后，当前实例的组件没有彻底销毁？不是。但不是由于多初引入导致的，而是由于没有主动将组件创建的闭包变量置null导致的。\r\n\r\n这次分析给了我们一个启示呢？在利用class Filter去搜索constructor，观察delta size是否为负数，freed size是否不为0，这样就可以判断出模块有没有彻底销毁。\r\n费了半天劲，最后只优化了0.012Kb，这不和没优化没差吗？\r\n试着从VueComponent的对比找找原因：在产品列表快照，我们发现了残留的未被销毁的素材列表的Table组件。\r\n\r\n所以几乎可以确定的是，切换到素材列表页面的Table组件，没有被完全销毁，在产品列表中依然可以找到它的身影。\r\n所以，是iView的Table组件存在内存泄露？还是vue本身存在内存泄露？\r\n再经过对比element-ui和iView，发现iView确实是存在内存泄漏的，内存占用一直降不下来，而element-ui过一会儿就会降到正常值。所以不是Vue的原因。\r\n和老大讨论了一下，之后可能会替换成其他的UI框架。\r\n目前的方案是监听window.performance.memory对象，一段时间内持续大于某个阀值时，会提醒用户主动刷新页面，从而释放出泄露掉的内存。\r\n\r\n关于iView内存泄露的讨论：\r\n\r\ngithub.com/iview/iview…\r\ngithub.com/iview/iview…\r\nwww.v2ex.com/t/587573#re…\r\n\r\n我的验证方式：\r\n\r\niView官网几次切换后停留到同一个页面，element-ui官网切换 观察同一个页面的内存占用\r\n本地项目几次切换后停留到同一个页面，对比VueComponent个数，并找出其他页面的组件\r\n\r\n就拿这个来说，我做了如下的切换foo->bar->foo->baz->foo后，获取到这个快照对比。\r\n从图上可以看出，VueComponent新建了612个，删除了9个，净增603个，分配了17.296Kb的内存，释放了0.504Kb的内存（看到这个释放程度我真的佛了），净增16.792Kb的内存。造成了16.792Kb的内存泄露。\r\n可能你觉得16.792Kb不算什么，因为它在我的这次分析里，内存泄露情况只排第19，排名第一第二的分别泄露了598Kb，506Kb。\r\n\r\nChrome DevTools Elements的Event Listeners分析内存泄露\r\nvue中的全局事件销毁，避免listener内存泄露。\r\nDOM0级事件销毁\r\nwindow.onbeforeunload = () => {};\r\nwindow.onbeforeunload = null; // 销毁，可以在vue的destroyed生命周期（最好在这个，因为无需在beforeDestroy引用vue实例）或beforeDestroy。\r\n复制代码DOM2级事件销毁\r\nthis.foo= (e) => {}\r\nwindow.addEventListener(\'resize\', this.foo);\r\nwindow.removeEventListener(\'resize\', this.foo);// 销毁，可以在vue的beforeDestroy生命周期（引用vue实例最好在这个周期销毁）或destroyed。\r\n复制代码全局事件销毁前（内存释放前）：\r\n\r\n通过观察可以发现，一次菜单切换，减少了一个冗余的全局事件监听器，性能有些许提升。\r\n总结与思考\r\n经过一系列分析我们发现，可以通过以下几种方式分析内存泄露的问题并修复。\r\n\r\n监听在window的事件没有解绑\r\n绑在EventBus的事件没有解绑\r\n第三方库创建的实例没有调用销毁函数\r\n自定义组件/模块闭包内部变量未被销毁\r\n\r\n前端同学在选型前端UI框架时，不妨先测试测试是否存在内存泄露。\r\n斯世浊清，全赖吾辈激扬！\r\n\r\n作者：趁你还年轻233\r\n链接：https://juejin.im/post/5d6e751ef265da03ae7892c3\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',1567578860081,'233'),(20,'15分钟搭一个企业级脚手架','【手把手】15分钟搭一个企业级脚手架\r\n1 写在前面的话\r\n搭一个脚手架，考验了你的 nodejs 水平、工程化能力、以及工具服务的设计能力，是前端进阶不可或缺的过程\r\n\r\n笔者在开发 cli 的过程中，调研流行的 cli 并形成最佳实践，本文旨在用最短的篇幅实现主要功能，揭露核心原理，同时提供 demo 仓库与大家学习探讨。\r\n\r\n通篇阅读大约需要 10 分钟，基于本教程自己撸一个 cli 大约需要花费 15 分钟\r\n\r\n仓库清单： 文章博客 | 脚手架-全局命令包 | 脚手架-模板插件包 | 脚手架-构建插件包\r\n\r\n2 脚手架的雏形\r\n其实脚手架的初衷，就是提供一个最佳实践的基础模板，因此模板拷贝是其核心功能\r\n\r\n几年前我曾写过一个极简的脚手架，大该干了这么一件事儿\r\n\r\nnpm publish 一个全局安装的包\r\n执行命令时，wget 我云服务上的一个压缩包，并在当前文件夹下解压\r\n一个命令，就可以把我预设的完整的工程目录创建好，特别方便效率。\r\n\r\n我想，这应该算是一个雏形脚手架吧\r\n\r\n3 脚手架需要考虑的\r\n上面雏形脚手架可以很好的服务于个人需求，但是毕竟过于干瘪和简陋，要想成为被大家广泛接受的工具，还需要完善。\r\n\r\n大家熟知的 vue-cli create-react-app @tarojs/cli umi 最基本功能：首先提出一些列问题选项，然后为你的新建项目提供一份模板并安装依赖，再提供调试构建命令\r\n\r\n没错，最核心的部分就是这个思路；但如果要做成一个可伸缩的、用户友好的，还需考虑这些需求：\r\n\r\n模板支持版本管理\r\n支持扩展新模板\r\n自动检测版本更新\r\n根据用户选择，生成个性化模板\r\n友好的UI界面\r\n构建功能独立，可因模板而异 (如区分H5/PC/weapp/RN)\r\n多人合作项目，能确保构建结果一致\r\n看起来信息量有点大，但其实都并不晦涩，我们一一说明一下意图\r\n\r\n3.1 模板支持版本管理\r\n比如用户使用 v1.0.0 的模板创建了项目，半年后，已经迭代升级到了 v2.0.0。我们需要依旧能够找到 v1.0.0 版本，因为老用户不想或者不方便升级。\r\n\r\n像我之前的雏形脚手架，将模板打一个压缩包放在云服务器上是不可行的，一旦更新就全量替换了\r\n\r\nnpm 仓库天然支持版本管理，因此将模板发布到 npm 上自然解决了这个问题 (非开源项目，可考虑自建仓库或者私有的仓库)\r\n\r\n3.2 支持扩展新模板\r\n比如我们一开始我们的脚手架支持 H5 的模板。\r\n\r\n半年后，随着业务发展，需支持微信小程序的模板。\r\n\r\n此时，我们无需额外再开发一个 cli，而是让 cli 一开始设计的就支持扩展，这符合了开放封闭的设计原则\r\n\r\n3.3 自动检测版本更新\r\nnpm 提供了一些命令来检测包的版本，比如你 npm view react version 返回 16.9.0，告知你最新版本\r\n\r\n借此，可以判断用户目前安装的是否最新版本，并提示用户更新\r\n\r\n3.4 根据用户选择，生成个性化模板\r\n模板虽说是为了统一，但也要在统一中支持差异，可通过问询用户，来提供差异化支持，比如：\r\n\r\n',1566230400000,'maoday'),(21,'JS 前20个常用字符串方法及使用方式','本文主要介绍一些最常用的JS字符串函数,列表如下：\r\n\r\ncharAt(x)\r\ncharCodeAt(x)\r\nconcat(v1,v2..)\r\nfromCharcode(c1,c2)\r\nindexOf(substr, [start])\r\nlastIndexOf(substr, [start])\r\nmatch(regexp)\r\nreplace(regexp/substr, replacetext)\r\nsearch(regexp)\r\nslice(start, [end])\r\nsplit(delimiter, [limit])\r\nsubstr(start, [length])\r\nsubstring(from, [to])\r\ntoLowerCase()\r\ntoUpperCase()\r\nincludes()\r\nendsWith()\r\nrepeat()\r\nvalueOf()\r\ntrim()\r\n\r\n1. charAt(x)\r\ncharAt(x)返回字符串中x位置的字符，下标从 0 开始。\r\n//charAt(x)\r\nvar myString = \'jQuery FTW!!!\';\r\nconsole.log(myString.charAt(7));\r\n//output: F\r\n复制代码\r\n2.charCodeAt(x)\r\ncharCodeAt(x)返回字符串中x位置处字符的unicode值。\r\n//charCodeAt(position)\r\nvar message=\"jquery4u\"\r\n//alert \"113\"\r\nalert(message.charCodeAt(1)\r\n复制代码\r\n3.concat(v1,v2..)\r\nconcat() 方法用于连接两个或多个字符串，此方法不改变现有的字符串，返回拼接后的新的字符串。\r\n//concat(v1, v2,..)\r\nvar message=\"Sam\"\r\nvar final=message.concat(\" is a\",\" hopeless romantic.\")\r\n//alerts \"Sam is a hopeless romantic.\"\r\nalert(final)\r\n复制代码\r\n4.fromCharcode(c1,c2)\r\nfromCharcode(c1,c2)转换一组Unicode值转换为字符。\r\n//fromCharCode(c1, c2,...)\r\nconsole.log(String.fromCharCode(97,98,99,120,121,122))\r\n//output: abcxyz\r\nconsole.log(String.fromCharCode(72,69,76,76,79))\r\n//output: HELLO\r\n复制代码\r\n5.indexOf(substr, [start])\r\nindexOf方法搜索并(如果找到)返回字符串中搜索到的字符或子字符串的索引。如果没有找到，则返回-1。Start是一个可选参数，指定字符串中开始搜索的位置，默认值为0。\r\n//indexOf(char/substring)\r\nvar sentence=\"Hi, my name is Sam!\"\r\nif (sentence.indexOf(\"Sam\")!=-1)\r\nalert(\"Sam is in there!\")\r\n复制代码\r\n6.lastIndexOf(substr, [start])\r\nlastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引, 如果未找到，则返回-1。 “Start”是一个可选参数，指定字符串中开始搜索的位置, 默认值为string.length-1。\r\n//lastIndexOf(substr, [start])\r\nvar myString = \'javascript rox\';\r\nconsole.log(myString.lastIndexOf(\'r\'));\r\n//output: 11\r\n复制代码\r\n7.match(regexp)\r\n根据正则表达式在字符串中搜索匹配项。如果没有找到匹配项，则返回一个信息数组或null。\r\n//match(regexp) //select integers only\r\nvar intRegex = /[0-9 -()+]+$/;  \r\n \r\nvar myNumber = \'999\';\r\nvar myInt = myNumber.match(intRegex);\r\nconsole.log(isInt);\r\n//output: 999\r\n \r\nvar myString = \'999 JS Coders\';\r\nvar myInt = myString.match(intRegex);\r\nconsole.log(isInt);\r\n//output: null\r\n复制代码\r\n8.replace(regexp/substr, replacetext)\r\nreplace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\r\n//replace(substr, replacetext)\r\nvar myString = \'999 JavaScript Coders\';\r\nconsole.log(myString.replace(/JavaScript/i, \"jQuery\"));\r\n//output: 999 jQuery Coders\r\n \r\n//replace(regexp, replacetext)\r\nvar myString = \'999 JavaScript Coders\';\r\nconsole.log(myString.replace(new RegExp( \"999\", \"gi\" ), \"The\"));\r\n//output: The JavaScript Coders\r\n复制代码\r\n9.search(regexp)\r\nsearch() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，如果找到，返回与 regexp 相匹配的子串的起始位置，否则返回 -1。\r\n//search(regexp)\r\nvar intRegex = /[0-9 -()+]+$/;  \r\n \r\nvar myNumber = \'999\';\r\nvar isInt = myNumber.search(intRegex);\r\nconsole.log(isInt);\r\n//output: 0\r\n复制代码\r\n10.slice(start, [end])\r\nslice() 方法可提取字符串的某个部分，返回一个新的字符串。包括字符串从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符。\r\n//slice(start, end)\r\nvar text=\"excellent\"\r\ntext.slice(0,4) //returns \"exce\"\r\ntext.slice(2,4) //returns \"ce\"\r\n复制代码\r\n11.split(delimiter, [limit])\r\nsplit() 方法用于把一个字符串分割成字符串数组，返回一个字符串数组返回的数组中的字串不包括 delimiter自身。 可选的“limit”是一个整数，允许各位指定要返回的最大数组的元素个数。\r\n12.substr(start, [length])\r\nsubstr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。返回一个新的字符串，包含从 start（包括 start 所指的字符） 处开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到该字符串的结尾的字符。\r\n//substr(from, to)\r\nvar text=\"excellent\"\r\ntext.substr(0,4) //returns \"exce\"\r\ntext.substr(2,4) //returns \"cell\"\r\n复制代码\r\n13.substring(from, [to])\r\nsubstring() 方法用于提取字符串中介于两个指定下标之间的字符，方返回的子串包括 start 处的字符，但不包括 stop 处的字符，to 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。\r\n//substring(from, [to])\r\nvar myString = \'javascript rox\';\r\nmyString = myString.substring(0,10);\r\nconsole.log(myString)\r\n//output: javascript\r\n复制代码\r\n14.toLowerCase()\r\ntoLowerCase() 方法用于把字符串转换为小写。\r\n//toLowerCase()\r\nvar myString = \'JAVASCRIPT ROX\';\r\nmyString = myString.toLowerCase();\r\nconsole.log(myString)\r\n//output: javascript rox\r\n复制代码\r\n15.toUpperCase()\r\ntoUpperCase() 方法用于把字符串转换为大写。\r\n//toUpperCase()\r\nvar myString = \'javascript rox\';\r\nmyString = myString.toUpperCase();\r\nconsole.log(myString)\r\n//output: JAVASCRIPT ROX\r\n复制代码\r\n16. includes()\r\nincludes() 方法用于检查字符串是否包含指定的字符串或字符。\r\n//includes()\r\nvar mystring = \"Hello, welcome to edureka\";\r\nvar n = mystring.includes(\"edureka\");\r\n//output: True\r\n复制代码\r\n17. endsWith()\r\nendsWith()函数检查字符串是否以指定的字符串或字符结束。\r\n//endsWith()\r\nvar mystr = \"List of javascript functions\";\r\nvar n = mystr.endsWith(\"functions\");\r\n//output: True\r\n复制代码\r\n18. repeat()\r\nrepeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。\r\n//repeat()\r\nvar string = \"Welcome to Edureka\";\r\nstring.repeat(2);\r\n//output: Welcome to Edureka Welcome to Edureka\r\n复制代码\r\n19. valueOf()\r\nvalueOf() 方法返回一个String对象的原始值（primitive value），该值等同于String.prototype.toString()。\r\n//valueOf()\r\nvar mystr = \"Hello World!\";\r\nvar res = mystr.valueOf();\r\n//output: Hello World!\r\n复制代码\r\n20. trim()\r\ntrim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）\r\n//trim()\r\nvar str = \"     Hello Edureka!     \";\r\nalert(str.trim());\r\n复制代码\r\n代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 Fundebug。\r\n\r\n作者：前端小智\r\n链接：https://juejin.im/post/5d6866936fb9a06ada54c642\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。',1567008000000,'xiaozhi');

/*Table structure for table `users` */

DROP TABLE IF EXISTS `users`;

CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL,
  `password` varchar(32) NOT NULL,
  `realname` varchar(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `users` */

insert  into `users`(`id`,`username`,`password`,`realname`) values (1,'xiaosheng','e12b39c5d874d8da9de74ea9e2083657','小生方勤'),(3,'ricklee','e12b39c5d874d8da9de74ea9e2083657','Rick_Lee'),(4,'yck','e12b39c5d874d8da9de74ea9e2083657','yck'),(5,'zuo','e12b39c5d874d8da9de74ea9e2083657','zuo'),(6,'bug_killer','e12b39c5d874d8da9de74ea9e2083657','bug_killer'),(7,'James','e12b39c5d874d8da9de74ea9e2083657','James'),(8,'233','e12b39c5d874d8da9de74ea9e2083657','233'),(9,'maoday','e12b39c5d874d8da9de74ea9e2083657','maoday'),(10,'xiaozhi','e12b39c5d874d8da9de74ea9e2083657','xiaozhi');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
